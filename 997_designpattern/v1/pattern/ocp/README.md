# “객체는 하나의 책임만을 맡아야 한다”

- SRP는 대상이 함수나 메소드가 아닌 객체라는 점에 주목할 것
- 객체는 둘 이상의 책임을 갖지 않는 형태를 가져야 함
- 즉, 두 개 이상의 메소드가 프로퍼티를 가졌을 때 책임이 그 수만큼 늘어나게 된다면 과감하게 분리
- SRP는 하나의 객체가 두개의 책임을 가지는 것 만큼이나 두 개의 객체가 하나의 책임을 나누는 것에 주의를 기울여야 함
- 단일 요구 사항의 변경으로 둘 이상의 객체가 변경을 요하는 상황에 처한다면 책임이 나뉘었다고 판단하고, 하나의 객체가 온전히 책임을 다 가질 수 있도록 해주어야 함.
- 클래스에 있어서 책임이란 클래스에 할당된 비즈니스 로직에 대한 요구를 말한다. File 클래스는 파일 처리라는 책임을 맡고 있고, String 클래스는 문자열 표현과 처리라는 책임을 맡고 있다. 단일 책임의 원칙은 하나의 클래스는 하나의 책임만을 맡아야 한다는 원칙이며, 이는 ‘높은 응집도와 낮은 결합도 원칙’을 지킬 수 있도록 해주는 세부 원칙이라 할 수 있다

**여기서의 책임은 순수하게 하나에 대한 책임을 이야기한다.**  

- 억지로 책임을 나누지 말아야 한다. 책임은 하나의 변화의 축이며, 하나의 요구 사항 변경은 하나의 책임을 직시하는 경우가 많다. 책임의 입자도가 매우 세밀하다면 변경에 대한 영역이 그만큼 커지게 된다. 변화가 예측되는 곳, 변화에 효율적으로 대응할 수 있는 크기에서 책임을 할당하는 것이 좋다.
- 하나는 온전한 하나이어야 한다. 하나의 클래스가 여러가지 책임을 맡는 것도 곤란하지만, 하나의 책임을 여러 클래스로 분할하여 할당하는 것도 곤란하다. 전자는 클래스가 여러 원인에 의해 변경되도록 하며, 후자는 하나의 원인으로 인해 여러 클래스가 변경되도록 한다.
- 확실하게 책임에 대한 구현을 은닉해 놓았다면 한 클래스에 두 개의 책임이 혼재 하더라도 변경으로 외부에 미치는 영향을 최소화 할 수 있다.

# Code Base 에 의한 설명 

Nexen Tire 는 오직 Nexen Tire를 위한 책임만을 가진다. 바퀴는 앞, 뒤로만 움직일 수 있다.  
Tire가 가져야할 책임은 하나의 책임만을 가진다. 만약 여기에서 왼쪽, 오른쪽으로 가게하는 것이 바퀴의 역할인가? 아니다.  
그렇기에 왼쪽, 오른쪽에 대한 처리를 위[nexen_tire.go](car%2Fnexen_tire.go)해서 Move Forward와 Backward의 처리 프로세스는 변경되어야 한다! 

이 때의 변경이 Forward 안에 왼쪽, 오른쪽으로 가는 기능을 넣으면 SRP의 Rule 깨게 된다.   

여기에서 객체 지향 설계를 위한 패턴 및 다양한 개발 방식에 대한 내용을 논의해볼 수 있다. 

바퀴는 앞으로 구르고, 뒤로 움직이는 구조이다.  
중요한 부분은 바퀴가 앞,뒤로만 움직일수 있다는 사실이고, 바퀴의 방향을 바꾸는 것은 구동축에 의해서 바뀌기 때문에  
구동축에 대한 상태는 별도로 갱신되고, 해당 시점에 상태에 따라서 바퀴의 방향이 대각선으로 바뀌게 되는 것이다. 
즉, 구동축은 방향만을 지정하는 책임을, 타이어는 방향에 따라서 실제 그 방향으로 이동될 수 있게 하는 것.  
이것이 명확힌 책임의 분리가 일어나는 부분이 된다. 